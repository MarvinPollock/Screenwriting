require 'openid'                    # Einbinden der benötigten Bibliotheken aus den Gems
require 'openid/store/filesystem'   # Store fürs Speichern der OpenID-Transaktionsdaten
require 'openid/consumer/discovery' # Yadis Discovery Funktionalitäten
require 'openid/extensions/sreg'    # Simple Registration Funktionalitäten
require 'openid/extensions/ax'      # Attribute Exchange Funktionalitäten

class OpenIdController < ApplicationController

  skip_before_filter :verify_authenticity_token

  # Die start-Action initialisiert die Anfrage, dabei werden auch die angeforderten Attribute
  # angegeben, welche in diesem Fall mittels Attribute Exchange angefordert werden.
  def new
    begin
      # In diesem Fall wird der Identity Provider des Fachbereich 3 direkt angesprochen. Wenn es
      # möglich sein soll, dass der Benutzer einen Identity Provider seiner Wahl angeben kann,
      # dann muss der begin-Methode die vom Benutzer angegebene OpenID-URL übergeben werden.
      oidreq = openid_consumer.begin(identity_provider)
    rescue OpenID::OpenIDError => e
      failed_login("Der OpenID-Server #{identity_provider} konnte nicht kontaktiert werden.<br />#{e}")
      return
    end
    # Anfrage von Benutzerdaten mittels Attribute Exchange. In diesem Fall werden relativ
    # viele Attribute angefragt, es empfiehlt sich, jedoch nur die Daten anzufordern,
    # welche auch für die Anwendung benötigt werden.
    #
    # Erster Parameter bei der Attributanfrage ist der Type Identifier, des gewünschten
    # Attributs. Eine Liste aller verfügbaren Attribute findet sich unter:
    # https://openid.tzi.de/spec/schema
    #
    # Zweiter Parameter ist der Bezeichner des Attributs, welcher dem Benutzer dargestellt wird.
    # Der dritte Parameter ist ein Boolean und kennzeichnet Attribute als erforderlich (true) oder
    # optional (false). Als vierter Parameter kann zusätzlich die Anzahl der Werte für das Attribut
    # angegeben werden - standardmäßig ist dies 1.
    axreq = OpenID::AX::FetchRequest.new
    requested_attrs = [
        ['http://openid.tzi.de/spec/schema/mail', 'E-Mail', true],
        ['http://openid.tzi.de/spec/schema/givenName', 'Vorname'],
        ['http://openid.tzi.de/spec/schema/surName', 'Nachname']]
    requested_attrs.each { |a| axreq.add(OpenID::AX::AttrInfo.new(a[0], a[1], a[2] || false, a[3] || 1)) }
    oidreq.add_extension(axreq)

    # Anfrage absenden: Der erste Parameter der Redirects ist das "Trust Root",
    # die Root-URL der Anwendung, für welche der Benutzer sich authentisieren soll.
    # Zweiter Parameter ist die Adresse der complete Action (siehe Routes oben)
    openid_complete_url = session_url
    if oidreq.send_redirect?(root_path, openid_complete_url)
      redirect_to oidreq.redirect_url(root_path, openid_complete_url)
    else
      @form_text = oidreq.form_markup(root_path, openid_complete_url, false, { 'id' => 'checkid_form' })
    end
  end

  # Die complete-Action nimmt die Antwort des OpenID-Servers entgegen
  # und verarbeitet die übergebenen Attribute
  def create
    oidparams = params.reject{ |k,v| request.path_parameters[k] }
    oidresp = openid_consumer.complete(oidparams, url_for({}))
    # Überprüfung ob die Antwort vom OpenID-Server des Fachbereich 3 kommt. Wenn auch andere
    # Identity Provider zulässig sein sollen, dann muss diese Abfrage entfernt werden.
    if oidresp && oidresp.endpoint && oidresp.endpoint.server_url.match(identity_provider)
      # Wenn die Anfrage bestätigt wurde, wird der Benutzer anhand der OpenID identifiziert
      if oidresp.status == OpenID::Consumer::SUCCESS
        @user, data = User.find_or_initialize_by_identity_url(oidresp.display_identifier), {}
        # Wenn Attribute übergeben wurden, werden diese dem lokalen Benutzerkonto zugewiesen.
        # An dieser Stelle ist es relativ anwendungsspezifisch, welche Daten angefordert wurden
        # und wie diese auf die Attribute des Benutzerkontos mappen, daher ist an dieser Stelle
        # Anpassungsarbeit erforderlich.
        if ax_resp = OpenID::AX::FetchResponse.from_success_response(oidresp)
          data[:email] = ax_resp.data['http://openid.tzi.de/spec/schema/mail'][0] unless ax_resp.data['http://openid.tzi.de/spec/schema/mail'][0].blank?
          data[:first_name] = ax_resp.data['http://openid.tzi.de/spec/schema/givenName'][0] unless ax_resp.data['http://openid.tzi.de/spec/schema/givenName'][0].blank?
          data[:last_name] = ax_resp.data['http://openid.tzi.de/spec/schema/surName'][0] unless ax_resp.data['http://openid.tzi.de/spec/schema/surName'][0].blank?
        end
        # Lokales Benutzerkonto ggf. mit den Daten vo Identity Provider abgleichen
        @user.update_attributes(data) unless data.empty?
        # Den Benutzer einloggen, sofern ein lokales Benutzerkonto eingerichtet werden konnte.
        # Die Funktionen dazu (logged_in?, successful_login, etc.) sind eher als Pseudocode zu
        # sehen, da diese anwendungsspezifisch implementiert werden müssen.
        self.current_user = @user unless @user.new_record?
        logged_in? ? successful_login : failed_login('Das Login mit OpenID ist fehlgeschlagen, da erforderliche Daten nicht freigegeben wurden.')
      else
        render :action => 'problem'
      end
    else
      redirect_to new_session_path
    end
  end

  def destroy
    session[:user_id] = nil
    redirect_to root_path
  end

  private

  # Die Daten der OpenID-Transaktionen werden in diesem Fall im Dateisystem abgelegt.
  # Sollte dies nicht erwünscht sein, kann auch ein anderer Store-Mechanismus angegeben
  # werden - näheres dazu findet sich in der Dokumentation des ruby-openid Gems unter:
  # http://www.openidenabled.com/ruby-openid/
  def openid_consumer
    url = Rails.root.join('tmp', 'openid')
    store = OpenID::Store::Filesystem.new(url)
    @openid_consumer ||= OpenID::Consumer.new(session, store)
  end

  # Die URL des Identity Providers - in diesem Fall die URL
  # des OpenID-Servers des Fachbereich 3 der Uni Bremen
  def identity_provider
    'https://openid.tzi.de/'
  end

end